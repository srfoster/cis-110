#!/usr/bin/env node

/**
 * Build-time compiler for YAML and Markdown files
 * Converts all textbook content into JavaScript modules for better performance
 */

import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const PUBLIC_DIR = path.join(__dirname, '../public');
const TEXTBOOK_DIR = path.join(PUBLIC_DIR, 'textbook');
const OUTPUT_DIR = path.join(__dirname, '../src/compiled');
const WIKI_DIR = path.join(PUBLIC_DIR, 'wiki');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

/**
 * Convert a file path to a valid JavaScript module name
 */
function pathToModuleName(filePath) {
  return filePath
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/^_+|_+$/g, '')
    .replace(/_+/g, '_');
}

/**
 * Recursively scan directory for files with given extensions
 */
function scanDirectory(dirPath, extensions = ['.yml', '.yaml', '.md']) {
  const files = [];
  
  if (!fs.existsSync(dirPath)) {
    return files;
  }
  
  function walkDir(currentPath) {
    const items = fs.readdirSync(currentPath);
    
    for (const item of items) {
      const fullPath = path.join(currentPath, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        walkDir(fullPath);
      } else if (stat.isFile()) {
        const ext = path.extname(item).toLowerCase();
        if (extensions.includes(ext)) {
          const relativePath = path.relative(dirPath, fullPath).replace(/\\/g, '/');
          files.push({
            fullPath,
            relativePath,
            extension: ext,
            name: path.basename(item, ext)
          });
        }
      }
    }
  }
  
  walkDir(dirPath);
  return files;
}

/**
 * Compile YAML files to JavaScript modules
 */
function compileYamlFiles() {
  console.log('ğŸ“„ Compiling YAML files...');
  
  const yamlFiles = scanDirectory(TEXTBOOK_DIR, ['.yml', '.yaml']);
  const compiledFiles = [];
  
  yamlFiles.forEach(file => {
    try {
      console.log(`  Processing: ${file.relativePath}`);
      
      const content = fs.readFileSync(file.fullPath, 'utf8');
      const data = yaml.load(content);
      
      const moduleName = pathToModuleName(file.relativePath);
      const outputFile = path.join(OUTPUT_DIR, `${moduleName}.js`);
      
      const moduleContent = `// Auto-generated from ${file.relativePath}
// Do not edit this file directly - edit the source YAML file instead

export default ${JSON.stringify(data, null, 2)};

export const metadata = {
  sourceFile: ${JSON.stringify(file.relativePath)},
  compiledAt: ${JSON.stringify(new Date().toISOString())},
  type: 'yaml'
};
`;
      
      fs.writeFileSync(outputFile, moduleContent);
      
      compiledFiles.push({
        sourceFile: file.relativePath,
        outputFile: path.relative(OUTPUT_DIR, outputFile),
        moduleName,
        type: 'yaml',
        data
      });
      
    } catch (error) {
      console.error(`âŒ Error processing ${file.relativePath}:`, error.message);
    }
  });
  
  console.log(`âœ… Compiled ${compiledFiles.length} YAML files`);
  return compiledFiles;
}

/**
 * Compile Markdown files to JavaScript modules
 */
function compileMarkdownFiles() {
  console.log('ğŸ“ Compiling Markdown files...');
  
  const mdFiles = scanDirectory(TEXTBOOK_DIR, ['.md']);
  const wikiFiles = scanDirectory(WIKI_DIR, ['.md']);
  const allMdFiles = [
    ...mdFiles.map(f => ({ ...f, type: 'textbook' })),
    ...wikiFiles.map(f => ({ ...f, type: 'wiki', relativePath: `wiki/${f.relativePath}` }))
  ];
  
  const compiledFiles = [];
  
  allMdFiles.forEach(file => {
    try {
      console.log(`  Processing: ${file.relativePath}`);
      
      const content = fs.readFileSync(file.fullPath, 'utf8');
      
      const moduleName = pathToModuleName(file.relativePath);
      const outputFile = path.join(OUTPUT_DIR, `${moduleName}.js`);
      
      const moduleContent = `// Auto-generated from ${file.relativePath}
// Do not edit this file directly - edit the source Markdown file instead

export default ${JSON.stringify(content)};

export const metadata = {
  sourceFile: ${JSON.stringify(file.relativePath)},
  compiledAt: ${JSON.stringify(new Date().toISOString())},
  type: 'markdown',
  contentType: ${JSON.stringify(file.type)}
};
`;
      
      fs.writeFileSync(outputFile, moduleContent);
      
      compiledFiles.push({
        sourceFile: file.relativePath,
        outputFile: path.relative(OUTPUT_DIR, outputFile),
        moduleName,
        type: 'markdown',
        contentType: file.type
      });
      
    } catch (error) {
      console.error(`âŒ Error processing ${file.relativePath}:`, error.message);
    }
  });
  
  console.log(`âœ… Compiled ${compiledFiles.length} Markdown files`);
  return compiledFiles;
}

/**
 * Generate index file with all compiled content inlined
 */
function generateIndex(yamlFiles, markdownFiles) {
  console.log('ğŸ“‹ Generating index...');
  
  const allFiles = [...yamlFiles, ...markdownFiles];
  
  // Read and inline all content instead of importing separate files
  const registry = allFiles.map(file => {
    const outputPath = path.join(OUTPUT_DIR, file.outputFile);
    const content = fs.readFileSync(outputPath, 'utf8');
    
    // Extract the default export content from the generated file
    const defaultExportMatch = content.match(/export default ([\s\S]+?);\s*$/m);
    const metadataMatch = content.match(/export const metadata = ([\s\S]+?);\s*$/m);
    
    if (!defaultExportMatch || !metadataMatch) {
      throw new Error(`Failed to parse content from ${file.outputFile}`);
    }
    
    return `  '${file.sourceFile}': {
    module: ${defaultExportMatch[1]},
    metadata: ${metadataMatch[1]},
    type: '${file.type}',
    ${file.contentType ? `contentType: '${file.contentType}',` : ''}
  }`;
  }).join(',\n');
  
  const indexContent = `// Auto-generated compilation index
// This file provides access to all compiled YAML and Markdown content (inlined)

export const compiledFiles = {
${registry}
};

export function getCompiledFile(path) {
  const file = compiledFiles[path];
  if (!file) {
    throw new Error(\`Compiled file not found: \${path}\`);
  }
  return file.module;
}

export function getFileMetadata(path) {
  const file = compiledFiles[path];
  if (!file) {
    throw new Error(\`Compiled file not found: \${path}\`);
  }
  return file.metadata;
}

export function listCompiledFiles(type = null) {
  if (type) {
    return Object.keys(compiledFiles).filter(path => compiledFiles[path].type === type);
  }
  return Object.keys(compiledFiles);
}

// Statistics
export const stats = {
  totalFiles: ${allFiles.length},
  yamlFiles: ${yamlFiles.length},
  markdownFiles: ${markdownFiles.length},
  compiledAt: '${new Date().toISOString()}'
};

console.log('ğŸ“š Compiled content loaded:', stats);
`;
  
  fs.writeFileSync(path.join(OUTPUT_DIR, 'index.js'), indexContent);
  console.log('âœ… Generated index.js with inlined content');
}

/**
 * Generate TypeScript definitions for better IDE support
 */
function generateTypeDefinitions() {
  console.log('ğŸ”· Generating TypeScript definitions...');
  
  const defsContent = `// Auto-generated TypeScript definitions for compiled content

export interface CompiledFileMetadata {
  sourceFile: string;
  compiledAt: string;
  type: 'yaml' | 'markdown';
  contentType?: 'textbook' | 'wiki';
}

export interface CompiledFile {
  module: any;
  metadata: CompiledFileMetadata;
  type: 'yaml' | 'markdown';
  contentType?: 'textbook' | 'wiki';
}

export interface CompilationStats {
  totalFiles: number;
  yamlFiles: number;
  markdownFiles: number;
  compiledAt: string;
}

export declare const compiledFiles: Record<string, CompiledFile>;
export declare const stats: CompilationStats;

export declare function getCompiledFile(path: string): any;
export declare function getFileMetadata(path: string): CompiledFileMetadata;
export declare function listCompiledFiles(type?: 'yaml' | 'markdown'): string[];
`;
  
  fs.writeFileSync(path.join(OUTPUT_DIR, 'index.d.ts'), defsContent);
  console.log('âœ… Generated TypeScript definitions');
}

/**
 * Clean up old compiled files
 */
function cleanOutput() {
  console.log('ğŸ§¹ Cleaning output directory...');
  
  if (fs.existsSync(OUTPUT_DIR)) {
    const files = fs.readdirSync(OUTPUT_DIR);
    files.forEach(file => {
      fs.unlinkSync(path.join(OUTPUT_DIR, file));
    });
  }
  
  console.log('âœ… Cleaned output directory');
}

/**
 * Main compilation function
 */
function main() {
  console.log('ğŸš€ Starting content compilation...');
  console.log(`ğŸ“ Textbook directory: ${TEXTBOOK_DIR}`);
  console.log(`ğŸ“ Wiki directory: ${WIKI_DIR}`);
  console.log(`ğŸ“ Output directory: ${OUTPUT_DIR}`);
  
  cleanOutput();
  
  const yamlFiles = compileYamlFiles();
  const markdownFiles = compileMarkdownFiles();
  
  generateIndex(yamlFiles, markdownFiles);
  generateTypeDefinitions();
  
  // Clean up individual files since we've inlined everything into index.js
  console.log('ğŸ§¹ Cleaning up individual files...');
  const allFiles = [...yamlFiles, ...markdownFiles];
  allFiles.forEach(file => {
    const filePath = path.join(OUTPUT_DIR, file.outputFile);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
  });
  console.log('âœ… Cleaned up individual files');
  
  console.log('ğŸ‰ Compilation complete!');
  console.log(`ğŸ“Š Total files compiled: ${yamlFiles.length + markdownFiles.length}`);
  console.log(`   ğŸ“„ YAML: ${yamlFiles.length}`);
  console.log(`   ğŸ“ Markdown: ${markdownFiles.length}`);
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}` || process.argv[1].includes('compile-content.js')) {
  main();
}

export { main, compileYamlFiles, compileMarkdownFiles };